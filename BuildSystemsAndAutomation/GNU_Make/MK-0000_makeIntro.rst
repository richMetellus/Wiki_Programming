.. _GNU_MakeIntro:

#################
GNU Make
#################

****************
Make Tool
****************

Make is a UNIX tool and is used as a tool to simplify building executable from different modules 
of a project. There are various rules that are specified as target entries in the makefile.


**Syntax**

* General form: ``make <target-label>``

    * ex: ``make clean``, ``make all``

    * the target-label is specified in the :ref:`Makefile`

.. _Makefile:

***********
Makefile
***********

A makefile 

* is nothing but a text file that is used or referenced by the ``make`` command to 
  build the targets. 

* contains information like source-level dependencies for each 
  file as well as the build-order dependencies.

   * The *make utility* automatically determines which pieces of a large program 
     need to be recompiled, and issues commands to recompile them.

* Makefiles are white-space sensitive. so indentation matter

Makefiles Rule
=================

A simple makefile consists of “rules” with the following format:

    .. code-block:: bash
       :caption: rule format

        target: dependencies
            recipe

* we press tab (NOT 4 space) and indicate some ``action`` to do in order to build the ``target``
  whenever one of its ``dependencies`` change

A :term:`target` is usually the name of a file that is generated by a program; examples of targets 
are executable or :term:`object files`. 
    
* A target can also be the name of an action to carry out, such as `clean` 
  (see Phony Targets).

  * :term:`phony target` is one that is not really the name of a file; rather 
    it is just a name for a recipe to be executed when you make an explicit 
    request

A :term:`prerequisite` or :term:`dependency` is a file that is used as input to create the target. 
A target often depends on several files.

A `recipe`` is an action that make carries out.

* A recipe may have more than one command, either on the same line or each on its own line. 

.. important:: 
    
    Please note: you need to put a tab character at the beginning of every recipe line!


*************
Demo
*************

A Simple C++ project with Makefile
======================================

Create a folder with the following document

.. code-block:: 

   tree A_SimpleMakefiletut/
   A_SimpleMakefiletut/
   ├── Makefile
   ├── main.cpp
   ├── message.cpp
   └── message.h
   
   0 directories, 4 files

The files have the original contents

.. tabs::
   
   .. tab:: main.cpp
      
      .. literalinclude:: /Programming/_resources/BuildSystemsAndAutomation/GNU_Make/gnu-make-tutorials/01_Essentials/A_SimpleMakefiletut/main.cpp
         :language: c++
         :linenos:

   .. tab:: message.h
      
      .. literalinclude:: /Programming/_resources/BuildSystemsAndAutomation/GNU_Make/gnu-make-tutorials/01_Essentials/A_SimpleMakefiletut/message.h
         :language: c++
         :linenos:

   .. tab:: message.cpp
      
      .. literalinclude:: /Programming/_resources/BuildSystemsAndAutomation/GNU_Make/gnu-make-tutorials/01_Essentials/A_SimpleMakefiletut/message.cpp
         :language: c++
         :linenos:

   .. tab:: Makefile
      
      .. literalinclude:: /Programming/_resources/BuildSystemsAndAutomation/GNU_Make/gnu-make-tutorials/01_Essentials/A_SimpleMakefiletut/Makefile
         :language: bash
         :linenos:

Breaking down the Makefile
------------------------------

By default, make starts with the first target (not targets whose names start with `.`). 
This is called the `default goal`. 

* In this example it is target that is the default goal is ``output``
* Looking at the first 2 lines:

    .. literalinclude:: /Programming/_resources/GNU_Make/gnu-make-tutorials/Makefile
       :language: bash
       :lines: 1-2

    * this form the rule for relinking "output", but before  make can fully process this rule, it
      must process the rules fro the files that ``output`` depends on, which in this case are the 
      object files ``*.o``

* in line 4, we are going to create ``main.o`` every time main.cpp changes. So when it changes
  take the action of just compiling ``-c``, no linking main.cpp into an :term:`object file`

    * so this create the ``main.o`` file

* line 10, 11 : one more rule ``clean``

    * This does not depend on anything and we can call it from the terminal
    * using the wildcard ``*``, remove anything that ends in .o and remove output.

**Building The project**

* In the directory where the Makefile is located at, simply run ``make`` from the terminal.

    .. code-block::
       
       $ make
       g++ -c main.cpp
       g++ -c message.cpp
       g++ main.o message.o -o output

* once everything is compiled and linked, the following files are now in the same directory

    #. main.o
    #. message.o
    #. output


**Run the executable binary produced**

.. code-block:: bash
   
   $ ./output
   Makefile Example

make is smart about what to rebuild

* Invoking the command ``make`` again will not update as no file has change.

    .. code-block:: bash
       
       $ make
       make: 'output' is up to date.

* Modify message.cpp and re-run ``make`` command, only the target message.o will be triggered, 
  and relinking is done.

    .. code-block:: bash
       
       $ make
       g++ -c message.cpp
       g++ main.o message.o -o output
